"use strict";(self.webpackChunksmart_data_lake=self.webpackChunksmart_data_lake||[]).push([[5270],{3905:(t,e,a)=>{a.d(e,{Zo:()=>m,kt:()=>f});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function o(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?o(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function l(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},o=Object.keys(t);for(n=0;n<o.length;n++)a=o[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(n=0;n<o.length;n++)a=o[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var s=n.createContext({}),p=function(t){var e=n.useContext(s),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},m=function(t){var e=p(t.components);return n.createElement(s.Provider,{value:e},t.children)},d="mdxType",u={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},c=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,o=t.originalType,s=t.parentName,m=l(t,["components","mdxType","originalType","parentName"]),d=p(a),c=r,f=d["".concat(s,".").concat(c)]||d[c]||u[c]||o;return a?n.createElement(f,i(i({ref:e},m),{},{components:a})):n.createElement(f,i({ref:e},m))}));function f(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=a.length,i=new Array(o);i[0]=c;var l={};for(var s in e)hasOwnProperty.call(e,s)&&(l[s]=e[s]);l.originalType=t,l[d]="string"==typeof t?t:r,i[1]=l;for(var p=2;p<o;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},7397:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const o={id:"transformations",title:"Transformations"},i=void 0,l={unversionedId:"reference/transformations",id:"reference/transformations",title:"Transformations",description:"Overview",source:"@site/docs/reference/transformations.md",sourceDirName:"reference",slug:"/reference/transformations",permalink:"/docs/reference/transformations",draft:!1,editUrl:"https://github.com/smart-data-lake/smart-data-lake/tree/documentation/docs/reference/transformations.md",tags:[],version:"current",frontMatter:{id:"transformations",title:"Transformations"},sidebar:"docs",previous:{title:"Execution Modes",permalink:"/docs/reference/executionModes"},next:{title:"Streaming",permalink:"/docs/reference/streaming"}},s={},p=[{value:"Overview",id:"overview",level:2},{value:"Example",id:"example",level:4},{value:"Predefined Transformations",id:"predefined-transformations",level:2},{value:"Custom Transformations",id:"custom-transformations",level:2},{value:"SQL",id:"sql",level:3},{value:"SQL 1-to-1",id:"sql-1-to-1",level:5},{value:"SQL many-to-many",id:"sql-many-to-many",level:5},{value:"Scala",id:"scala",level:3},{value:"As Scala class",id:"as-scala-class",level:5},{value:"In Configuration",id:"in-configuration",level:5},{value:"Python",id:"python",level:3},{value:"Requirements",id:"requirements",level:5},{value:"Options / RuntimeOptions",id:"options--runtimeoptions",level:3},{value:"In SQL",id:"in-sql",level:5},{value:"In Scala",id:"in-scala",level:5},{value:"In Python",id:"in-python",level:5}],m={toc:p},d="wrapper";function u(t){let{components:e,...a}=t;return(0,r.kt)(d,(0,n.Z)({},m,a,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"On all Spark related actions, you can add one or multiple transformers that are used to transform data before handing\nit over to the next action or writing the Data Object.\nIf you define multiple transformers for one action, they are processed sequentially (output of one transformer becomes input of the next).\nThis page describes the many out-of-the-box transformations and explains how to write your own. "),(0,r.kt)("p",null,"In all cases, two types of transformers need to be distinguished:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"1-to-1"),": One input Data Object is transformed into one output Data Object. "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"many-to-many"),": One or more input Data Objects are transformed into (potentially) many output Data Object.")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Although it's possible to create many output Data Object, it's encouraged to only create actions with one output Data Object.\nThe resulting lineage of the pipelines will be clearer and impact analysis easier.")),(0,r.kt)("h4",{id:"example"},"Example"),(0,r.kt)("p",null,"As a simple example, we add a WhitelistTransformer to a CopyAction.\nThis will result in only the given columns being selected from the input Data Object and any other columns being discarded."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"SampleWhitelistAction {\n    type = CopyAction\n    inputId = someInput\n    outputId = someOutput\n    transformers = [{\n        type = WhitelistTransformer\n        columnWhitelist = [includedColumn1,anotherColumn2]\n    }]\n}\n")),(0,r.kt)("p",null,"Note the square brackets: ",(0,r.kt)("em",{parentName:"p"},"transformers")," is an array as you can define multiple transformers."),(0,r.kt)("p",null,"The parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"columnWhitelist")," is dependent on the type of the transformer.\nFor details about given parameters / options, please see the ",(0,r.kt)("a",{parentName:"p",href:"../../JsonSchemaViewer"},"Configuration Schema Viewer"),"."),(0,r.kt)("h2",{id:"predefined-transformations"},"Predefined Transformations"),(0,r.kt)("p",null,"SDLB comes with commonly used transformers out-of-the-box."),(0,r.kt)("p",null,"The following predefined 1-to-1 transformations are supported:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Transformer"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AdditionalColumnsTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Add additional columns to the DataFrame by extracting information from the context  or derive new columns from existing columns")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"BlacklistTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Apply a column blacklist to discard columns")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DataValidationTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"validates DataFrame with a user defined set of rules and creates column with potential error messages")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"DecryptColumnsTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Decrypts specified columns using AES/GCM algorithm")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"EncryptColumnsTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Encrypts specified columns using AES/GCM algorithm")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"FilterTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Filter DataFrame with expression")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SparkRepartitionTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Repartitons a DataFrame")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"StandardizeColNamesTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Used to standardize column names according to configurable rules")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"StandardizeSparkDatatypesTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Standardize data types of a DataFrame (decimal to corresponding int / float)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"WhitelistTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Apply a column whitelist to a DataFrame")))),(0,r.kt)("h2",{id:"custom-transformations"},"Custom Transformations"),(0,r.kt)("p",null,"When these predefined transformations are not enough, you can easily write your own ",(0,r.kt)("em",{parentName:"p"},"Custom Transformations"),".\nSDLB currently supports SQL, Scala and Python transformations, depending on the complexity and needed libraries."),(0,r.kt)("p",null,"The following custom transformations are available."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Transformer"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SQLDfTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"SQL Transformation 1-to-1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SQLDfsTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"SQL Transformation many-to-many")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ScalaClassGenericDfTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Spark DataFrame transformation in Scala 1-to-1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ScalaClassGenericDfsTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Spark DataFrame transformation in Scala many-to-many")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ScalaClassSnowparkDfTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Snowpark (Snowflake) transformation in Scala 1-to-1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ScalaClassSnowparkDfsTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Snowpark (Snowflake) transformation in Scala many-to-many")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ScalaClassSparkDfTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Spark DataFrame transformation in Scala 1-to-1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ScalaClassSparkDfsTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Spark DataFrame transformation in Scala many-to-many")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ScalaClassSparkDsTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Spark DataSet transformation in Scala 1-to-1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ScalaClassSparkDsNTo1Transformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Spark DataFrame transformation in Scala many-to-one")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ScalaNotebookSparkDfTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Loads custom code from a Notebook")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PythonCodeSparkDfTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Spark DataFrame transformation in Python 1-to-1 (using PySpark)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PythonCodeSparkDfsTransformer"),(0,r.kt)("td",{parentName:"tr",align:null},"Spark DataFrame transformation in Python many-to-many (using PySpark)")))),(0,r.kt)("p",null,"There are usually two variants, one for 1-to-1 transformations called ",(0,r.kt)("em",{parentName:"p"},"DfTransformer")," and one\nfor many-to-many transformations called ",(0,r.kt)("em",{parentName:"p"},"DfsTransformer"),"."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The type of the transformer needs to match your action.\nThis is also apparent in the ",(0,r.kt)("a",{parentName:"p",href:"../../JsonSchemaViewer"},"Configuration Schema Viewer"),":",(0,r.kt)("br",{parentName:"p"}),"\n","1-to-1 transformers are listed under 1-to-1 actions, i.e. CopyAction.",(0,r.kt)("br",{parentName:"p"}),"\n","Many-to-many transformers are only listed under many-to-many actions, i.e. CustomDataFrameAction.")),(0,r.kt)("h3",{id:"sql"},"SQL"),(0,r.kt)("p",null,"Spark SQL is probably the easiest way to write a custom transformation, directly in your HOCON configuration.\nAll input Data Objects are available in the select statement with following naming:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"special characters are replaced by an underscore"),(0,r.kt)("li",{parentName:"ul"},"a postfix ",(0,r.kt)("inlineCode",{parentName:"li"},"_sdltemp")," is added.\nSo an input Data Object called ",(0,r.kt)("inlineCode",{parentName:"li"},"table-with-hyphen")," becomes ",(0,r.kt)("inlineCode",{parentName:"li"},"table_with_hyphen_sdltemp")," inside the SQL query.\nTo simplify this you can also use the special token ",(0,r.kt)("inlineCode",{parentName:"li"},"%{inputViewName}")," for 1-to-1 transformations, or ",(0,r.kt)("inlineCode",{parentName:"li"},"${inputViewName_<inputDataObjectName>}")," for n-to-m transformations, that will be replaced with the correct name at runtime.")),(0,r.kt)("h5",{id:"sql-1-to-1"},"SQL 1-to-1"),(0,r.kt)("p",null,"1-to-1 transformations use type SQLDfTransformer. "),(0,r.kt)("p",null,"Let's assume we have an input Data Object called dataObject1.\nWe can then write a SQL transformation directly in our HOCON configuration:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'transformers = [{\n  type = SQLDfTransformer\n  sqlCode = "select id, count(*) from %{inputViewName} group by id"\n}]\n')),(0,r.kt)("p",null,"The SQL code gets executed in Spark SQL so you can use all available functions."),(0,r.kt)("h5",{id:"sql-many-to-many"},"SQL many-to-many"),(0,r.kt)("p",null,"Many-to-many transformations use SQLDfsTransformer (note the additional s in Dfs).\nNow that we have multiple output Data Objects, we need to declare which SQL statements belongs to\nwhich Data Object.\nTherefore, we now have a map of objectIds and corresponding SQL statements:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"transformers = [{\n  type = SQLDfsTransformer\n  code = {\n    dataObjectOut1 = \"select id, cnt from %{inputViewName_dataObjectIn1} where group = 'test1'\",\n    dataObjectOut2 = \"select id, cnt from %{inputViewName_dataObjectIn1} where group = 'test2'\"\n  }\n}\n")),(0,r.kt)("h3",{id:"scala"},"Scala"),(0,r.kt)("p",null,"Once transformations get more complex, it's more convenient to implement them in Scala code.\nIn custom Scala code, the whole Spark Dataset API is available.\nIt's of course also possible to include additional libraries for your code,\nso anything you can do in Spark Scala, you can do with SDLB. "),(0,r.kt)("h5",{id:"as-scala-class"},"As Scala class"),(0,r.kt)("p",null,"If you have a Java/Scala project, it usually makes sense to create separate classes for your custom Scala code.\nAny classes in your classpath are picked up and can be referenced. "),(0,r.kt)("p",null,"To transform data in a 1-to-1 action, i.e. CopyAction:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"  my_action {\n    type = CopyAction\n    inputId = stg_input\n    outputId = int_output\n    transformers = [{\n      type = ScalaClassSparkDfTransformer\n      className = io.package.MyFirstTransformer\n    }]\n  }\n")),(0,r.kt)("p",null,"Now SDLB expects to find a class ",(0,r.kt)("em",{parentName:"p"},"MyFirstTransformer")," in the Scala package ",(0,r.kt)("em",{parentName:"p"},"io.package"),".\nThe class needs to extend CustomDfTransformer and with that, overwrite the transform method from it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'class MyFirstTransformer extends CustomDfTransformer {\n    override def transform(session: SparkSession, options: Map[String, String], df: DataFrame, dataObjectId: String) : DataFrame {\n        // manipulate df\n        val dfExtended = df.withColumn("newColumn", when($"df.desc".isNotNull, $"df.desc").otherwise(lit("na")))\n        dfExtended\n    }\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"transform")," method you need to overwrite receives a single DataFrame called ",(0,r.kt)("em",{parentName:"p"},"df"),".\nYou can manipulate this DataFrame any way you want.\nIn the end, you simply need to return a DataFrame back to SDLB."),(0,r.kt)("p",null,"Because a CopyAction is 1-to-1 only, the transformer also needs to extend the 1-to-1 ",(0,r.kt)("inlineCode",{parentName:"p"},"CustomDfTransformer"),"."),(0,r.kt)("p",null,"If you have a many-to-many action and want to write a custom Scala transformer, you need to switch to a ",(0,r.kt)("inlineCode",{parentName:"p"},"CustomDataFrameAction"),". "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"my_many_to_many_action {\n  type = CustomDataFrameAction\n  inputIds = [df1,df2]\n  outputIds = [dfOut]\n  transformers = [{\n    type = ScalaClassSparkDfsTransformer\n    class-name = io.package.MySecondTransformer\n  }]\n}\n")),(0,r.kt)("p",null,"In this case, your Scala class also needs to extend the many-to-many ",(0,r.kt)("inlineCode",{parentName:"p"},"CustomDfsTransformer")," and overwrite the respective transform method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'class MySecondTransformer extends CustomDfsTransformer {\n    def transform(session: SparkSession, options: Map[String,String], dfs: Map[String,DataFrame]) : Map[String,DataFrame] {\n        // now you have multiple input DataFrames and can potentially return multiple DataFrames\n        val df1 = dfs("df1")\n        val df2 = dfs("df2")\n        val combined = df1.join(df2, $"df1.id"==$"df2.fk", "left")\n        Map("dfOut"->combined)\n    }\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"transform")," method now gets a map with all your input DataFrames called ",(0,r.kt)("em",{parentName:"p"},"dfs"),".\nThe key in ",(0,r.kt)("em",{parentName:"p"},"dfs")," contains the dataObjectId, in this example we have two inputs called ",(0,r.kt)("em",{parentName:"p"},"df1")," and ",(0,r.kt)("em",{parentName:"p"},"df2"),",\nwe use it to extract the two DataFrames.\nAgain, you can manipulate all DataFrames as needed and this time, return a map with all output Data Objects.\nAs noted, it's best practice to only return one Data Object (many-to-one action) as in our example."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"One thing that might be confusing at this point:"),(0,r.kt)("p",{parentName:"admonition"},"CustomDataFrameAction is the type of the ",(0,r.kt)("strong",{parentName:"p"},"action")," itself.\nTake a look at the  ",(0,r.kt)("a",{parentName:"p",href:"../../JsonSchemaViewer"},"Configuration Schema Viewer"),":\nYou will see CustomDataFrameAction as a direct action type, similar to CopyAction or HistorizeAction."),(0,r.kt)("p",{parentName:"admonition"},"ScalaClassSparkDfsTransformer is the type of your ",(0,r.kt)("strong",{parentName:"p"},"transformer"),".\nIt needs to correspond to the action type. A 1-to-1 action, expects a 1-to-1 transformer.")),(0,r.kt)("h5",{id:"in-configuration"},"In Configuration"),(0,r.kt)("p",null,"If you don't work with a full Java/Scala project, it's still possible to define your transformations\nin your HOCON configuration and compile it at runtime.\nIn this case, use the transformer type ScalaCodeSparkDfTransformer."),(0,r.kt)("p",null,"To include the Scala code inline:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'myActionName {\n  type = CopyAction\n  inputId = stg-tbl1\n  outputId = int-tbl1\n  transformers = [{\n    type = ScalaCodeSparkDfTransformer\n    code = """\n      import org.apache.spark.sql.{DataFrame, SparkSession}\n      import org.apache.spark.sql.functions.explode\n      (session: SparkSession, options: Map[String,String], df: DataFrame, dataObjectId: String) => {\n        import session.implicits._\n        df.select("col1","col2")\n      }\n    """\n  }]\n')),(0,r.kt)("p",null,"Check the method signature in CustomDfTransformer and CustomDfsTransformer according to your requirements."),(0,r.kt)("h3",{id:"python"},"Python"),(0,r.kt)("p",null,"The transformer needs to use type ",(0,r.kt)("inlineCode",{parentName:"p"},"PythonCodeSparkDfTransformer")," (1-to-1) or ",(0,r.kt)("inlineCode",{parentName:"p"},"PythonCodeSparkDfsTransformer")," (many-to-many).\nYou can either provide it as separate file or inline as Python code again."),(0,r.kt)("p",null,"Inline 1-to-1 example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'transformers = [{\n  type = PythonCodeDfTransformer \n  code = """\n    |from pyspark.sql.functions import *\n    |udf_multiply = udf(lambda x, y: x * y, "int")\n    |dfResult = inputDf.select(col("name"), col("cnt"))\\\n    |  .withColumn("test", udf_multiply(col("cnt").cast("int"), lit(2)))\n    |setOutputDf(dfResult)\n  """\n}]\n')),(0,r.kt)("p",null,"PySpark is initialized automatically and the PySpark session is available under the variables\n",(0,r.kt)("inlineCode",{parentName:"p"},"sc"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"session")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"sqlContext"),".\nSome additional variables are also available:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"inputDf"),": Input DataFrame"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"dataObjectId"),": Id of input DataObject as string")),(0,r.kt)("p",null,"The output DataFrame needs to be set with ",(0,r.kt)("inlineCode",{parentName:"p"},"setOutputDf(df)"),"."),(0,r.kt)("p",null,"And many-to-many inline example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'transformers = [{\n  type = PythonCodeDfsTransformer \n  code = """\n    |dfResult = inputDfs[df1].join(inputDfs[df2], inputDfs[df1].id == inputDfs[df2].fk, "left") \\\n    |  .select(inputDfs[df1].id, inputDfs[df1].desc, inputDfs[df2].desc)\n    |setOutputDf({"outputId": dfResult})\n  """\n}]\n')),(0,r.kt)("p",null,"In this case, ",(0,r.kt)("inlineCode",{parentName:"p"},"inputDfs")," is a dictionary (dict) and ",(0,r.kt)("inlineCode",{parentName:"p"},"setOutputDf")," expects a dictionary."),(0,r.kt)("h5",{id:"requirements"},"Requirements"),(0,r.kt)("p",null,"Running Python transformations needs some additional setup.\nIn general, Python >= 3.4 is required and PySpark package needs to be installed with a version matching your SDL spark version. Further environment variable PYTHONPATH needs to be set to your python environment ",(0,r.kt)("inlineCode",{parentName:"p"},".../Lib/site-packages")," directory, and pyspark command needs to be accessible from the PATH environment variable."),(0,r.kt)("h3",{id:"options--runtimeoptions"},"Options / RuntimeOptions"),(0,r.kt)("p",null,"So far these transformations have been quite static:\nCode written can probably only be used for one specific action. "),(0,r.kt)("p",null,"For custom transformers, you can therefore provide additional options:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"options"),": static options provided in your HOCON configuration"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"runtimeOptions"),": extracted at runtime from the context. ")),(0,r.kt)("h5",{id:"in-sql"},"In SQL"),(0,r.kt)("p",null,"If you want to use options in SQL, the syntax is %{key}:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'transformers = [{\n  type = SQLDfTransformer\n  sqlCode = "select id, cnt, \'%{test}\' as test, %{last_run_id} as last_run_id from dataObject1"\n  options = {\n    test = "test run"\n  }\n  runtimeOptions = {\n    last_run_id = "runId - 1" // runtime options are evaluated as spark SQL expressions against DefaultExpressionData\n  }\n}]\n')),(0,r.kt)("h5",{id:"in-scala"},"In Scala"),(0,r.kt)("p",null,"If you check the signature of the ",(0,r.kt)("inlineCode",{parentName:"p"},"transform")," method again, you can see that you get more than just the DataFrames\nyou can manipulate.\nYou also get a Map","[String,String]"," called ",(0,r.kt)("inlineCode",{parentName:"p"},"options"),".\nThis Map contains the combined ",(0,r.kt)("inlineCode",{parentName:"p"},"options")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"runtimeOptions"),".\nSo in your custom class, you can read all options and runtimeOptions and use them accordingly to parametrize your code."),(0,r.kt)("h5",{id:"in-python"},"In Python"),(0,r.kt)("p",null,"Similarly in Python, in addition to the variables ",(0,r.kt)("inlineCode",{parentName:"p"},"inputDf")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"dataObjectId")," (resp. ",(0,r.kt)("inlineCode",{parentName:"p"},"inputsDfs'), you get a variable called "),"options",(0,r.kt)("inlineCode",{parentName:"p"},"containing all"),"options",(0,r.kt)("inlineCode",{parentName:"p"},"and"),"runtimeOptions`."))}u.isMDXComponent=!0}}]);