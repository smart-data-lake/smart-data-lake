"use strict";(self.webpackChunksmart_data_lake=self.webpackChunksmart_data_lake||[]).push([[9850],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(n),m=i,h=d["".concat(s,".").concat(m)]||d[m]||c[m]||r;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3888:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={title:"Housekeeping",description:"Use advanced housekeeping functions to optimize execution",slug:"sdl-housekeeping",authors:[{name:"Patrick Gr\xfctter",url:"https://github.com/pgruetter"}],tags:["housekeeping","performance","partitioning"],hide_table_of_contents:!1},o="Housekeeping",l={permalink:"/blog/sdl-housekeeping",editUrl:"https://github.com/smart-data-lake/smart-data-lake/tree/documentation/blog/2023-06-08-SDL-Housekeeping/2023-06-08-housekeeping.md",source:"@site/blog/2023-06-08-SDL-Housekeeping/2023-06-08-housekeeping.md",title:"Housekeeping",description:"Use advanced housekeeping functions to optimize execution",date:"2023-06-08T00:00:00.000Z",formattedDate:"June 8, 2023",tags:[{label:"housekeeping",permalink:"/blog/tags/housekeeping"},{label:"performance",permalink:"/blog/tags/performance"},{label:"partitioning",permalink:"/blog/tags/partitioning"}],readingTime:5.87,hasTruncateMarker:!1,authors:[{name:"Patrick Gr\xfctter",url:"https://github.com/pgruetter"}],frontMatter:{title:"Housekeeping",description:"Use advanced housekeeping functions to optimize execution",slug:"sdl-housekeeping",authors:[{name:"Patrick Gr\xfctter",url:"https://github.com/pgruetter"}],tags:["housekeeping","performance","partitioning"],hide_table_of_contents:!1},nextItem:{title:"Incremental historization using CDC and Airbyte MSSQL connector",permalink:"/blog/sdl-hist"}},s={authorsImageUrls:[void 0]},p=[{value:"Context",id:"context",level:2},{value:"Partitioning",id:"partitioning",level:2},{value:"Drawback",id:"drawback",level:2},{value:"HousekeepingMode",id:"housekeepingmode",level:2},{value:"PartitionArchiveCompactionMode",id:"partitionarchivecompactionmode",level:3},{value:"Archive",id:"archive",level:4},{value:"Compaction",id:"compaction",level:4},{value:"PartitionRetentionMode",id:"partitionretentionmode",level:3},{value:"Result",id:"result",level:2}],u={toc:p},d="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In this article, we're taking a look on how we use SDLB's housekeeping features to keep our pipelines running efficiently."),(0,i.kt)("p",null,"Some DataObject contain housekeeping features of their own.\nMake sure you use them!\nFor example, Delta Tables support commands like ",(0,i.kt)("inlineCode",{parentName:"p"},"optimize")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"vacuum")," to optimize storage and delete no longer needed files."),(0,i.kt)("p",null,"But usually, those commands do not re-organize your partitions.\nThis is where SDLBs housekeeping mode comes in."),(0,i.kt)("p",null,"The example is taken from a real world project we've implemented."),(0,i.kt)("h2",{id:"context"},"Context"),(0,i.kt)("p",null,"In this particular project we are collecting data from various reporting units and process it in batches.\nThe reporting units use an Azure Function to upload JSON files to an Azure Data Lake Storage.\nFrom there, we pick them up for validation and processing.\nReporting units can upload data anytime, but it is only processed a few times a day."),(0,i.kt)("p",null,"Once validated, we use Delta Lake tables in Databricks to process data through the layers of the Lakehouse."),(0,i.kt)("h2",{id:"partitioning"},"Partitioning"),(0,i.kt)("p",null,"The Azure Function puts uploaded JSON files in a subfolder for each reporting unit.\nAs such, JSON files are already neatly partitioned by ",(0,i.kt)("inlineCode",{parentName:"p"},"reporting_unit"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"uploadFolder/\n  reporting_unit=rp01\n    file1.json\n    file2.json\n    file3.json\n  reporting_unit=rp02\n    file1.json\n  reporting_unit=rp03\n    fileX.json\n")),(0,i.kt)("p",null,"To read these JSON files, we can therefore use the following DataObject definition:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"import_json {\n    type = JsonFileDataObject\n    path = uploadFolder/\n    partitions = [reporting_unit]    \n}\n")),(0,i.kt)("p",null,"These files are then processed with a ",(0,i.kt)("inlineCode",{parentName:"p"},"FileTransferAction")," into an output DataObject ",(0,i.kt)("inlineCode",{parentName:"p"},"stage_json"),": "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"stage_json {\n    type = FileTransferAction\n    inputId = import_json\n    outputId = stage_json\n    executionMode = { type = FileIncrementalMoveMode }\n    metadata.feed = stage_json\n}\n")),(0,i.kt)("p",null,"Each time we start to process uploaded data, we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"run_id")," to keep track of all batch jobs and version of files delivered.\nIf you use a state path (see ",(0,i.kt)("a",{parentName:"p",href:"../../docs/reference/commandLine"},"commandLine"),"),\nyour runs automatically generate a ",(0,i.kt)("inlineCode",{parentName:"p"},"run_id")," to identify the run, and you can use it by extending your DataObject:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'stage_json {\n    type = JsonFileDataObject\n    path = processedFolder\n    partitions = [run_id,reporting_unit]\n    schema = """reporting_unit string, run_id string, ...."""\n}\n')),(0,i.kt)("p",null,"Note how we just use run_id as part of the schema without any further declaration.\nSince we use the state path, SDLB uses a ",(0,i.kt)("inlineCode",{parentName:"p"},"run_id")," internally, and if it's referenced as partition column in a DataObject, processed data get automatically assigned the id of the current run."),(0,i.kt)("h2",{id:"drawback"},"Drawback"),(0,i.kt)("p",null,"Let's take a look at the resulting partition layout of ",(0,i.kt)("inlineCode",{parentName:"p"},"stage_json"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"processedFolder/\n  run_id=1/\n    reporting_unit=rp01/\n      file1.json\n      file2.json\n      file3.json\n    reporting_unit=rp02/\n      file1.json\n    reporting_unit=rp03/\n      fileX.json\n")),(0,i.kt)("p",null,"This partition layout has many advantages in our case as we know exactly\nduring which run a particular file was processed and which reporting unit uploaded it.\nIn further stages we can clearly work with files that were processed in the current run and not touch any old ",(0,i.kt)("inlineCode",{parentName:"p"},"run_id"),"s. "),(0,i.kt)("p",null,"For this use case, a few things are important to note:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Some reporting units don't upload data for days. You end up with only a few reporting_unit partitions per run_id."),(0,i.kt)("li",{parentName:"ul"},"File sizes are rather small (< 1 MiB), partition sizes end up very small too."),(0,i.kt)("li",{parentName:"ul"},"If you use hourly runs and run 24/7, you end up with 168 partitions per week, plus sub-partitions for reporting units."),(0,i.kt)("li",{parentName:"ul"},"Once files are correctly processed, we don't read the uploaded files anymore.\nWe still keep them as raw files should we ever need to re-process them.")),(0,i.kt)("p",null,"The drawback becomes apparent when you have actions working with all partitions, they will become very slow.\nSpark doesn't like a lot of small partitions."),(0,i.kt)("p",null,"To mitigate that, we use SDLB's Housekeeping Feature."),(0,i.kt)("h2",{id:"housekeepingmode"},"HousekeepingMode"),(0,i.kt)("p",null,"If you take a look at DataObject's parameters, you will see a ",(0,i.kt)("inlineCode",{parentName:"p"},"housekeepingMode"),".\nThere are two modes available:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"PartitionArchiveCompactionMode"),": to compact / archive partitions  "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"PartitionRetentionMode"),": to delete certain partitions completely")),(0,i.kt)("h3",{id:"partitionarchivecompactionmode"},"PartitionArchiveCompactionMode"),(0,i.kt)("p",null,"In this mode, you solve two tasks at once:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"You define how many smaller partitions are aggregated into one larger partition (archive)"),(0,i.kt)("li",{parentName:"ul"},"Rewrite all files in a partition to combine many small files into larger files (compact)")),(0,i.kt)("h4",{id:"archive"},"Archive"),(0,i.kt)("p",null,"In our example above, we stated that we don't want to alter any input files, so we won't use compaction.\nWe want to keep them as is (raw data).\nBut we do want to get rid of all the small partitions after a certain amount of time.\nFor that, we extend ",(0,i.kt)("inlineCode",{parentName:"p"},"stage_json")," to include the ",(0,i.kt)("inlineCode",{parentName:"p"},"housekeepingMode")," with a ",(0,i.kt)("inlineCode",{parentName:"p"},"archivePartitionExpression"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'stage_json {\n    type = JsonFileDataObject\n    path = processedFolder\n    partitions = [run_id,reporting_unit]\n    schema = """reporting_unit string, run_id string, ...."""\n    housekeepingMode = {\n      type = PartitionArchiveCompactionMode\n      archivePartitionExpression = "if( elements.run_id < (runId - 500), map(\'run_id\', (cast(elements.run_id as integer) div 500) * 500, \'reporting_unit\', elements.reporting_unit), elements)"\n    }\n}\n')),(0,i.kt)("p",null,"This expression probably needs some explanation:",(0,i.kt)("br",{parentName:"p"}),"\n","The Spark SQL expression works with attributes of ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/smart-data-lake/smart-data-lake/blob/master-spark3/sdl-core/src/main/scala/io/smartdatalake/workflow/dataobject/HousekeepingMode.scala#L136"},(0,i.kt)("inlineCode",{parentName:"a"},"PartitionExpressionData")),".\nIn this case we use ",(0,i.kt)("inlineCode",{parentName:"p"},"runId")," (the current runId) and ",(0,i.kt)("inlineCode",{parentName:"p"},"elements")," (all partition values as map(string,string)).\nIt needs to return a map(string,string) to define new partition values.\nIn our case, it needs to define ",(0,i.kt)("inlineCode",{parentName:"p"},"run_id")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"reporting_unit")," because these are the partitions defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"stage_json"),"."),(0,i.kt)("p",null,"Let's take the expression apart:",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"if(elements.run_id < (runId - 500), ..."),(0,i.kt)("br",{parentName:"p"}),"\n","Only archive the partition if it's runId is older than 500 run_ids ago. "),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"map('run_id', (cast(elements.run_id as integer) div 500) * 500, 'reporting_unit', elements.reporting_unit)"),(0,i.kt)("br",{parentName:"p"}),"\n","Creates the map with the new values for the partitions.\nThe run_id is floored to the next 500 value, so as example, the new value of run_id 1984 will be 1500 (because integer 1984/500=3, 3*500=1500).",(0,i.kt)("br",{parentName:"p"}),"\n","Remember that we need to return all partition values in the map, also the ones we don't want to alter.\nFor ",(0,i.kt)("inlineCode",{parentName:"p"},"reporting_unit")," we simply return the existing value ",(0,i.kt)("inlineCode",{parentName:"p"},"elements.reporting_unit"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"..., elements)"),(0,i.kt)("br",{parentName:"p"}),"\n","This is the else condition and simply returns the existing partition values if there is nothing to archive."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The housekeeping mode is applied after writing a DataObject.\nKeep in mind, that it is executed with every run.")),(0,i.kt)("h4",{id:"compaction"},"Compaction"),(0,i.kt)("p",null,"We don't want to compact files in our case.\nBut from the documentation you can see that compaction works very similarly:",(0,i.kt)("br",{parentName:"p"}),"\n","You also work with attributes from ",(0,i.kt)("inlineCode",{parentName:"p"},"PartitionExpressionData")," but instead of new partition values,\nyou return a boolean to indicate for each partition if it should be compacted or not. "),(0,i.kt)("h3",{id:"partitionretentionmode"},"PartitionRetentionMode"),(0,i.kt)("p",null,"Again, not used in our example as we never delete old files.\nBut if you need to, you define a Spark SQL expression returning a boolean indicating if a partition should be retained or deleted."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'stage_json {\n    type = JsonFileDataObject\n    path = processedFolder\n    partitions = [run_id,reporting_unit]\n    schema = """reporting_unit string, run_id string, ...."""\n    housekeepingMode = {\n      type = PartitionRetentionMode\n      retentionCondition = "elements.run_id > (runId - 500)"\n    }\n}\n')),(0,i.kt)("h2",{id:"result"},"Result"),(0,i.kt)("p",null,"In our example, we had performance gradually decreasing because Spark had to read more than 10'000 partitions and subpartitions.\nJust listing all available partitions, even if you only worked with the most recent one, took a few minutes and these operations added up."),(0,i.kt)("p",null,"With the housekeeping mode enabled, older partitions continuously get merged into larger partitions containing up to 500 runs.\nThis brought the duration of list operations back to a few seconds."),(0,i.kt)("p",null,"The operations are fully automated, no manual intervention is required."))}c.isMDXComponent=!0}}]);