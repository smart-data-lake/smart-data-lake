"use strict";(self.webpackChunksmart_data_lake=self.webpackChunksmart_data_lake||[]).push([[7014],{7370:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var i=t(5893),a=t(1151);const o={id:"executionEngines",title:"Execution Engines"},r=void 0,c={id:"reference/executionEngines",title:"Execution Engines",description:"An execution engine is a technology/library used by SDLB to transform data. SDLB supports different execution engines and is able to combine different execution engines in the same data pipeline / job.",source:"@site/docs/reference/executionEngines.md",sourceDirName:"reference",slug:"/reference/executionEngines",permalink:"/docs/reference/executionEngines",draft:!1,unlisted:!1,editUrl:"https://github.com/smart-data-lake/smart-data-lake/tree/documentation/docs/reference/executionEngines.md",tags:[],version:"current",frontMatter:{id:"executionEngines",title:"Execution Engines"},sidebar:"tutorialSidebar",previous:{title:"Execution Phases",permalink:"/docs/reference/executionPhases"},next:{title:"Execution Modes",permalink:"/docs/reference/executionModes"}},s={},d=[{value:"Connecting different execution engines",id:"connecting-different-execution-engines",level:3},{value:"Schema propagation",id:"schema-propagation",level:3},{value:"Determining execution engine to use in &quot;Generic DataFrame API&quot; Actions",id:"determining-execution-engine-to-use-in-generic-dataframe-api-actions",level:3},{value:"Execution Engines vs Execution Environments",id:"execution-engines-vs-execution-environments",level:3}];function l(e){const n={a:"a",h3:"h3",img:"img",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"An execution engine is a technology/library used by SDLB to transform data. SDLB supports different execution engines and is able to combine different execution engines in the same data pipeline / job.\r\nThe data structure used to transport data between DataObjects and Actions is called a SubFeed.\r\nEach Execution Engine has Subfeeds, Actions and Dataobjects associated with it."}),"\n",(0,i.jsx)(n.p,{children:"Currently SDLB supports the following execution engines:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Category"}),(0,i.jsx)(n.th,{children:"Execution Engine"}),(0,i.jsx)(n.th,{children:"SubFeed Name"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Supported Actions"}),(0,i.jsx)(n.th,{children:"Supported DataObjects"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Java-Byte-Stream"}),(0,i.jsx)(n.td,{children:"File Engine"}),(0,i.jsx)(n.td,{children:"FileSubFeed"}),(0,i.jsx)(n.td,{children:"Transfer Byte-Streams without further knowledge about their content"}),(0,i.jsx)(n.td,{children:"FileTransferAction, CustomFileAction"}),(0,i.jsx)(n.td,{children:"all HadoopFileDataObjects, WebserviceFileDataObject, SFtpFileDataObject"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Generic DataFrame API"}),(0,i.jsx)(n.td,{children:"Spark Engine"}),(0,i.jsx)(n.td,{children:"SparkSubFeed"}),(0,i.jsx)(n.td,{children:"Transform data with Spark DataFrame API"}),(0,i.jsx)(n.td,{children:"CopyAction, CustomDataFrameAction, DeduplicateAction, HistorizeAction"}),(0,i.jsx)(n.td,{children:"all Hadoop/SparkFileDataObject, AccessTableDataObject, AirbyteDataObject, CustomDfDataObject, DeltaLakeTableDataObject, HiveTableDataObject, JdbcTableDataObject, JmsDataObject, KafkaTopicDataObject, SnowflakeTableDataObject, SplunkDataObject, TickTockHiveTableDataObject"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Generic DataFrame API"}),(0,i.jsx)(n.td,{children:"Snowflake-Snowpark Engine"}),(0,i.jsx)(n.td,{children:"SnowparkSubFeed"}),(0,i.jsx)(n.td,{children:"Transform data within Snowflake with Snowpark DataFrame API"}),(0,i.jsx)(n.td,{children:"CopyAction, CustomDataFrameAction, DeduplicateAction, (HistorizeAction)"}),(0,i.jsx)(n.td,{children:"SnowflakeTableDataObject"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Script"}),(0,i.jsx)(n.td,{children:"Script Engine"}),(0,i.jsx)(n.td,{children:"ScriptSubFeed"}),(0,i.jsx)(n.td,{children:"Coordinate script task execution and notify DataObjects about script results"}),(0,i.jsx)(n.td,{children:"No public implementation for now"}),(0,i.jsx)(n.td,{children:"all DataObjects"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"connecting-different-execution-engines",children:"Connecting different execution engines"}),"\n",(0,i.jsx)(n.p,{children:"In order to build a data pipeline using different execution engines, you need a DataObject that supports both execution engines as interface, so that one execution engine can write the data in the DataObject and the other one can read from it."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"from FileSubFeed to SparkSubFeed (and vice-versa): any Hadoop/SparkFileDataObject like ParquetFileDataObject"}),"\n",(0,i.jsx)(n.li,{children:"from SparkSubFeed to SnowparkSubFeed (and vice-versa): SnowflakeTableDataObject"}),"\n",(0,i.jsx)(n.li,{children:"from ScriptSubFeed to any (and vice-versa): every DataObject is suitable"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"schema-propagation",children:"Schema propagation"}),"\n",(0,i.jsx)(n.p,{children:'Note that a schema can only be propagated within a data pipeline for consecutive actions running with an execution engine of category "Generic DataFrame API". Whenever such an Action has an input from a different category, the schema is read again from the DataObject.'}),"\n",(0,i.jsx)(n.p,{children:'SDLB is able to convert schemas between different execution engines of category "Generic DataFrame API", e.g. Spark and Snowpark.'}),"\n",(0,i.jsx)(n.h3,{id:"determining-execution-engine-to-use-in-generic-dataframe-api-actions",children:'Determining execution engine to use in "Generic DataFrame API" Actions'}),"\n",(0,i.jsx)(n.p,{children:'A "Generic DataFrame API" Action can run with different execution engines like Spark or Snowpark. It determines the execution engine to use in Init-phase by checking the supported types of inputs, outputs and transformations. The first common type is chosen. If there is no common type an exception is thrown.\r\nTo check which execution engine was chosen, look for logs like the following:'}),"\n",(0,i.jsx)(n.p,{children:"INFO  CustomDataFrameAction - (Action~...) selected subFeedType SparkSubFeed"}),"\n",(0,i.jsx)(n.h3,{id:"execution-engines-vs-execution-environments",children:"Execution Engines vs Execution Environments"}),"\n",(0,i.jsxs)(n.p,{children:["As mentioned in ",(0,i.jsx)(n.a,{href:"../../docs/architecture",children:"Architecture"}),", SDLB is first and foremost a Java (Scala) application.\r\nIt can run in any Execution Environment where you can install a JVM, executing Actions with any of its Execution Engines. SDLB chooses the Execution Engines for your data pipeline independently from the Execution Environment that SDLB lives in.\r\nFor example: Let's say you run SDLB in a distributed fashion on a Spark Cluster using spark-submit.\r\nIf one of your Actions only has SnowflakeTableDataObjects as input and output, SDLB will run it using the Snowpark-Engine.\r\nIn practice, this means that SDLB will connect to the Snowflake Environment from inside your Spark-Cluster and then execute your Action from there using Snowpark's Java/Scala Library."]}),"\n",(0,i.jsxs)(n.p,{children:["Of course, the Execution Environment you have influences the DataObjects that you have at your disposal: for instance, if you want to connect to Snowflake, you need a Snowflake account and be able to connect to Snowflake.\r\nBut the Execution Environment does not determine the Execution Engines SDLB will use - your DataObjects, Actions and Transformations do.\r\n",(0,i.jsx)(n.img,{alt:"img.png",src:t(2290).Z+"",width:"1148",height:"588"})]})]})}function u(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},2290:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/execution_engines_layers-a188259e2ae4a851154ebbcf23d993ae.png"},1151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>r});var i=t(7294);const a={},o=i.createContext(a);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);