"use strict";(self.webpackChunksmart_data_lake=self.webpackChunksmart_data_lake||[]).push([[5270],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>d});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),l=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=l(e.components);return n.createElement(p.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=l(a),d=r,c=u["".concat(p,".").concat(d)]||u[d]||f[d]||o;return a?n.createElement(c,i(i({ref:t},m),{},{components:a})):n.createElement(c,i({ref:t},m))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=u;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=a[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},7397:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>f,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var n=a(7462),r=(a(7294),a(3905));const o={id:"transformations",title:"Transformations"},i=void 0,s={unversionedId:"reference/transformations",id:"reference/transformations",title:"Transformations",description:"This page is under review",source:"@site/docs/reference/transformations.md",sourceDirName:"reference",slug:"/reference/transformations",permalink:"/docs/reference/transformations",draft:!1,editUrl:"https://github.com/smart-data-lake/smart-data-lake/tree/documentation/docs/reference/transformations.md",tags:[],version:"current",frontMatter:{id:"transformations",title:"Transformations"},sidebar:"docs",previous:{title:"Execution Modes",permalink:"/docs/reference/executionModes"},next:{title:"Streaming",permalink:"/docs/reference/streaming"}},p={},l=[{value:"Spark Transformations",id:"spark-transformations",level:2},{value:"Predefined Transformations",id:"predefined-transformations",level:3},{value:"Custom Transformations",id:"custom-transformations",level:3},{value:"Scala/Java",id:"scalajava",level:4},{value:"SQL",id:"sql",level:4},{value:"Python",id:"python",level:4}],m={toc:l};function f(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"This page is under review ")),(0,r.kt)("h2",{id:"spark-transformations"},"Spark Transformations"),(0,r.kt)("p",null,"To implement custom transformation logic, specify ",(0,r.kt)("strong",{parentName:"p"},"transformers")," attribute of an Action.\nIt allows you to chain several transformations in a linear process, where the output SubFeeds of one transformation are used as input for the next."),(0,r.kt)("p",null,"Depending on your Action type the transformations have different format (described later). The two types are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"1-to-1")," transformations (","*","DfTransformer): One input DataFrame is transformed into one output DataFrame. This is the case for ",(0,r.kt)("em",{parentName:"li"},"CopyAction"),", ",(0,r.kt)("em",{parentName:"li"},"DeduplicateAction")," and ",(0,r.kt)("em",{parentName:"li"},"HistorizeAction"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"many-to-many")," transformations (","*","DfsTransformer): Many input DataFrames can be transformed into many output DataFrames. This is the case for ",(0,r.kt)("em",{parentName:"li"},"CustomDataFrameAction"),".")),(0,r.kt)("p",null,"The configuration allows you to use ",(0,r.kt)("a",{parentName:"p",href:"#predefined-transformations"},(0,r.kt)("em",{parentName:"a"},"predefined standard transformations"))," or to define ",(0,r.kt)("a",{parentName:"p",href:"#custom-transformations"},(0,r.kt)("em",{parentName:"a"},"custom transformation"))," in various languages."),(0,r.kt)("admonition",{title:"Deprecation Warning",type:"warning"},(0,r.kt)("p",{parentName:"admonition"}," there has been a refactoring of transformations in Version 2.0.5. The attribute ",(0,r.kt)("strong",{parentName:"p"},"transformer")," is deprecated and will be removed in future versions. Use ",(0,r.kt)("strong",{parentName:"p"},"transformers")," instead.")),(0,r.kt)("h3",{id:"predefined-transformations"},"Predefined Transformations"),(0,r.kt)("p",null,"Predefined transformations implement generic logic to be reused in different actions.\nDepending on the transformer there are a couple of properties you can specify, see ",(0,r.kt)("a",{parentName:"p",href:"../../JsonSchemaViewer"},"Configuration Schema Viewer"),".\nThe following Transformers exist:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"AdditionalColumnsTransformer (1-to-1): Add additional columns to the DataFrame by extracting information from the context")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"BlacklistTransformer (1-to-1): Apply a column blacklist to a DataFrame")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"ColNamesLowercaseTransformer (1-to-1): change column name to lower case column names in output")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"DataValidationTransformer (1-to-1): validates DataFrame with user defined set of rules and creates column with potential error messages")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"FilterTransformer (1-to-1): Filter DataFrame with expression")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"StandardizeDatatypesTransformer (1-to-1): Standardize data types of a DataFrame")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"WhitelistTransformer (1-to-1): Apply a column whitelist to a DataFrame")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"SparkRepartitionTransformer (1-to-1): Repartions a DataFrame")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"DfTransformerWrapperDfsTransformer (many-to-many): use 1-to-1 transformer as many-to-many transformer by specifying the SubFeeds it should be applied to"))),(0,r.kt)("h3",{id:"custom-transformations"},"Custom Transformations"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Custom transformers")," provide an easy way to define your own data transformation logic in SQL, Scala/Java, and Python.\nThe transformation can be defined within the configuration file or in a separate code file. "),(0,r.kt)("p",null,"Additionally, static ",(0,r.kt)("strong",{parentName:"p"},"options")," and ",(0,r.kt)("strong",{parentName:"p"},"runtimeOptions")," can be defined within the custom transformers. ",(0,r.kt)("em",{parentName:"p"},"runtimeOptions")," are extracted at runtime from the context.\nSpecifying options allows to reuse a transformation in different settings. For an example see SQL example below."),(0,r.kt)("h4",{id:"scalajava"},"Scala/Java"),(0,r.kt)("p",null,"In general, Scala/Java transformations can be provided within the configuration file or in seperate source files.\nYou can use Spark Dataset API in Java/Scala to define custom transformations.\nIf you have a Java project, create a class that extends CustomDfTransformer or CustomDfsTransformer and implement ",(0,r.kt)("inlineCode",{parentName:"p"},"transform")," method.\nThen use ",(0,r.kt)("strong",{parentName:"p"},"type = ScalaClassSparkDfTransformer")," or ",(0,r.kt)("strong",{parentName:"p"},"type = ScalaClassSparkDfsTransformer")," and configure ",(0,r.kt)("strong",{parentName:"p"},"className")," attribute."),(0,r.kt)("p",null,"If you work without Java project, it's still possible to define your transformation in Java/Scala and compile it at runtime.\nFor a 1-to-1 transformation use ",(0,r.kt)("strong",{parentName:"p"},"type = ScalaCodeSparkDfTransformer")," and configure ",(0,r.kt)("strong",{parentName:"p"},"code")," or ",(0,r.kt)("strong",{parentName:"p"},"file")," as a function that takes ",(0,r.kt)("inlineCode",{parentName:"p"},"session: SparkSession, options: Map[String,String], df: DataFrame, dataObjectName: String")," as parameters and returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"DataFrame"),".\nFor many-to-many transformations use ",(0,r.kt)("strong",{parentName:"p"},"type = ScalaCodeSparkDfsTransformer")," and configure ",(0,r.kt)("strong",{parentName:"p"},"code")," or ",(0,r.kt)("strong",{parentName:"p"},"file")," as a function that takes ",(0,r.kt)("inlineCode",{parentName:"p"},"session: SparkSession, options: Map[String,String], dfs: Map[String,DataFrame]")," with DataFrames per input DataObject as parameter, and returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"Map[String,DataFrame]")," with the DataFrame per output DataObject."),(0,r.kt)("p",null,"Examples within the configuration file:\nExample 1-to-1: select 2 specific columns (",(0,r.kt)("inlineCode",{parentName:"p"},"col1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"col2"),") from ",(0,r.kt)("inlineCode",{parentName:"p"},"stg-tbl1")," into ",(0,r.kt)("inlineCode",{parentName:"p"},"int-tbl"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'  myactionName {\n    metadata.feed = myfeedName\n    type = CopyAction\n    inputId = stg-tbl1\n    outputId = int-tbl1\n    transformer = {\n      scalaCode = """\n        import org.apache.spark.sql.{DataFrame, SparkSession}\n        import org.apache.spark.sql.functions.explode\n        (session: SparkSession, options: Map[String,String], df: DataFrame, dataObjectId: String) => {\n          import session.implicits._\n          df.select("col1","col2")\n        }\n      """\n    }\n    ...\n')),(0,r.kt)("p",null,"Example many-to-many: joining ",(0,r.kt)("inlineCode",{parentName:"p"},"stg-tbl1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"stg-tbl2")," using two indexes, note the mapping of DataFrames:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'  myactionName {\n    metadata.feed = myfeedName\n    type = CustomDataFrameAction\n    inputIds = [stg-tbl1, stg-tbl2]\n    outputIds = [int-tab12]\n    transformers = [{\n      type = ScalaCodeSparkDfsTransformer\n      code = """\n        import org.apache.spark.sql.{DataFrame, SparkSession}\n        // define the function, with this fixed argument types)\n        (session: SparkSession, options: Map[String,String], dfs: Map[String,DataFrame]) => {\n          import session.implicits._\n          val df_in1 = dfs("stg-tbl1")         // here we map the input DataFrames\n          val df_in2 = dfs("stg-tbl2")\n          val df_res = df_in1.join(df_in2, $"tbl1_id" === $"tbl2_id", "left").drop("tbl2_id")\n        Map("int-tbl12" -> df_res)             // map output DataFrame\n        }\n      """\n    }]\n  }\n')),(0,r.kt)("p",null,"See more examples at ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/smart-data-lake/sdl-examples"},"sdl-examples"),"."),(0,r.kt)("h4",{id:"sql"},"SQL"),(0,r.kt)("p",null,"You can use Spark SQL to define custom transformations.\nInput DataObjects are available as tables to select from. Use tokens %{","<","key",">","} to replace with runtimeOptions in SQL code.\nFor a 1-to-1 transformation use ",(0,r.kt)("strong",{parentName:"p"},"type = SQLDfTransformer")," and configure ",(0,r.kt)("strong",{parentName:"p"},"code")," as your SQL transformation statement.\nFor many-to-many transformations use ",(0,r.kt)("strong",{parentName:"p"},"type = SQLDfsTransformer")," and configure ",(0,r.kt)("strong",{parentName:"p"},"code"),' as a Map of "',"<","outputDataObjectId",">",", ","<","SQL transformation statement",">",'".'),(0,r.kt)("p",null,"Example - using options in sql code for 1-to-1 transformation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'transformers = [{\n  type = SQLDfTransformer\n  name = "test run"\n  description = "description of test run..."\n  sqlCode = "select id, cnt, \'%{test}\' as test, %{run_id} as last_run_id from dataObject1"\n  options = {\n    test = "test run"\n  }\n  runtimeOptions = {\n    last_run_id = "runId - 1" // runtime options are evaluated as spark SQL expressions against DefaultExpressionData\n  }\n}]\n')),(0,r.kt)("p",null,"Example - defining a many-to-many transformation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"transformers = [{\n  type = SQLDfsTransformer\n  code = {\n    dataObjectOut1 = \"select id,cnt from dataObjectIn1 where group = 'test1'\",\n    dataObjectOut2 = \"select id,cnt from dataObjectIn1 where group = 'test2'\"\n  }\n}\n")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/smart-data-lake/sdl-examples"},"sdl-examples")," for details."),(0,r.kt)("h4",{id:"python"},"Python"),(0,r.kt)("p",null,"It's also possible to use Python to define a custom Spark transformation.\nFor a 1-to-1 transformation use ",(0,r.kt)("strong",{parentName:"p"},"type = PythonCodeDfTransformer")," and configure ",(0,r.kt)("strong",{parentName:"p"},"code")," or ",(0,r.kt)("strong",{parentName:"p"},"file")," as a python function.\nPySpark session is initialize and available under variables ",(0,r.kt)("inlineCode",{parentName:"p"},"sc"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"session"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"sqlContext"),".\nOther variables available are"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"inputDf"),": Input DataFrame"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"options"),": Transformation options as Map","[String,String]"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"dataObjectId"),": Id of input DataObject as String")),(0,r.kt)("p",null,"Output DataFrame must be set with ",(0,r.kt)("inlineCode",{parentName:"p"},"setOutputDf(df)"),"."),(0,r.kt)("p",null,"For now using Python for many-to-many transformations is not possible, although it would be not so hard to implement."),(0,r.kt)("p",null,"Example - apply some python calculation as udf:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'transformers = [{\n  type = PythonCodeDfTransformer \n  code = """\n    |from pyspark.sql.functions import *\n    |udf_multiply = udf(lambda x, y: x * y, "int")\n    |dfResult = inputDf.select(col("name"), col("cnt"))\\\n    |  .withColumn("test", udf_multiply(col("cnt").cast("int"), lit(2)))\n    |setOutputDf(dfResult)\n  """\n}]\n')),(0,r.kt)("p",null,"Requirements:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Spark 2.4.x:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Python version >= 3.4 an <= 3.7"),(0,r.kt)("li",{parentName:"ul"},"PySpark package matching your spark version"))),(0,r.kt)("li",{parentName:"ul"},"Spark 3.x:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Python version >= 3.4"),(0,r.kt)("li",{parentName:"ul"},"PySpark package matching your spark version")))),(0,r.kt)("p",null,"See Readme of ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/smart-data-lake/sdl-examples"},"sdl-examples")," for a working example and instructions to setup python environment for IntelliJ"),(0,r.kt)("p",null,"How it works: under the hood a PySpark DataFrame is a proxy for a Java Spark DataFrame. PySpark uses Py4j to access Java objects in the JVM."))}f.isMDXComponent=!0}}]);