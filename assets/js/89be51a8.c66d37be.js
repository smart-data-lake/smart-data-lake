"use strict";(self.webpackChunksmart_data_lake=self.webpackChunksmart_data_lake||[]).push([[7749],{4901:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>c,toc:()=>d});var i=n(5893),s=n(1151);const a={id:"actions",title:"Actions"},o=void 0,c={id:"reference/actions",title:"Actions",description:"Actions describe dependencies between input and output DataObjects and necessary transformation to connect them.",source:"@site/docs/reference/actions.md",sourceDirName:"reference",slug:"/reference/actions",permalink:"/docs/reference/actions",draft:!1,unlisted:!1,editUrl:"https://github.com/smart-data-lake/smart-data-lake/tree/documentation/docs/reference/actions.md",tags:[],version:"current",frontMatter:{id:"actions",title:"Actions"},sidebar:"tutorialSidebar",previous:{title:"Data Objects",permalink:"/docs/reference/dataObjects"},next:{title:"Hocon Configurations",permalink:"/docs/reference/hoconOverview"}},r={},d=[{value:"Transformations",id:"transformations",level:2},{value:"MetaData",id:"metadata",level:2},{value:"ExecutionMode",id:"executionmode",level:2},{value:"executionCondition",id:"executioncondition",level:2},{value:"metricsFailCondition",id:"metricsfailcondition",level:2},{value:"recursiveInputIds",id:"recursiveinputids",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Actions describe dependencies between input and output DataObjects and necessary transformation to connect them."}),"\n",(0,i.jsxs)(t.p,{children:["Some Actions allow only one input and one output, e.g. CopyAction, others can cope with several inputs and outputs, e.g. CustomDataFrameActions. As a best practice implement ",(0,i.jsxs)(t.em,{children:["n",":m"]})," Actions only if you have a good reason, otherwise stick to ",(0,i.jsx)(t.strong,{children:"1:1"}),", ",(0,i.jsxs)(t.em,{children:["1",":n"]})," and ",(0,i.jsx)(t.em,{children:"n:1"})," Actions in order to know exact dependencies from metadata."]}),"\n",(0,i.jsx)(t.h2,{id:"transformations",children:"Transformations"}),"\n",(0,i.jsxs)(t.p,{children:["These can be custom transformers in SQL, Scala/Spark, or Python, OR predefined transformations like Copy, Historization and Deduplication, see ",(0,i.jsx)(t.a,{href:"transformations",children:"Transformations"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"metadata",children:"MetaData"}),"\n",(0,i.jsxs)(t.p,{children:["As for DataObjects and Connections, various metadata can be provided for Action items. These help manage and explore data in the Smart Data Lake. Beside ",(0,i.jsx)(t.em,{children:"name"})," and ",(0,i.jsx)(t.em,{children:"description"}),", a ",(0,i.jsx)(t.em,{children:"feed"})," and a list of ",(0,i.jsx)(t.em,{children:"tags"})," can be specified."]}),"\n",(0,i.jsx)(t.h2,{id:"executionmode",children:"ExecutionMode"}),"\n",(0,i.jsxs)(t.p,{children:["By default, all data in the specified DataObjects are processed. The execution mode option provides the possibility to select the data to process, e.g. partially process them. This can be specific partitions or also incremental processing. See ",(0,i.jsx)(t.a,{href:"executionModes",children:"ExecutionMode"})," for detailled description of the various possibilities."]}),"\n",(0,i.jsx)(t.h2,{id:"executioncondition",children:"executionCondition"}),"\n",(0,i.jsxs)(t.p,{children:["By default, an Action is executed if all inputs are available, e.g. no input from a previous Action is skipped.\nOverride the default behaviour by specifying an ",(0,i.jsx)(t.em,{children:"executionCondition"})," in SQL syntax on the Action. It is evaluated against the properties available in [[SubFeedsExpressionData]]. If true, the Action is executed, otherwise it is skipped. Details see also [[Condition]]."]}),"\n",(0,i.jsx)(t.p,{children:"Example: execute if input stg-src1 is not skipped."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'  action1 {\n    type = CustomDataFrameAction\n    inputIds = [stg-src1, stg-src2]\n    outputIds = [int-tgt]\n    executionCondition = {\n      description = "execute if input stg-src1 is not skipped"\n      expression = "!inputSubFeeds.stg-src1.isSkipped"\n    }\n    ...\n'})}),"\n",(0,i.jsx)(t.h2,{id:"metricsfailcondition",children:"metricsFailCondition"}),"\n",(0,i.jsxs)(t.p,{children:["Specify a condition in SQL syntax checking the metrics created by an Action. The expression is evaluated as where-clause against dataframe of metrics with columns ",(0,i.jsx)(t.code,{children:"dataObjectId"}),", ",(0,i.jsx)(t.code,{children:"key"}),", ",(0,i.jsx)(t.code,{children:"value"}),". If there are any rows passing the where clause, the Action is failed (MetricCheckFailed exception) and further execution is stopped."]}),"\n",(0,i.jsxs)(t.p,{children:["To fail an action writing to output ",(0,i.jsx)(t.code,{children:"int-tgt"})," in case there are no records written, specify ",(0,i.jsx)(t.code,{children:"\"dataObjectId = 'int-tgt' and key = 'no_data' and value = true\""}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["This functionality is similar to ",(0,i.jsx)(t.a,{href:"dataQuality#Expectations",children:"Expectations"}),", but the ",(0,i.jsx)(t.em,{children:"metricsFailCondition"})," is defined on an Action and instead of a DataObject. And it can access all metrics produced by an Action, not the custom metric defined by the Expectation."]}),"\n",(0,i.jsx)(t.h2,{id:"recursiveinputids",children:"recursiveInputIds"}),"\n",(0,i.jsx)(t.p,{children:"In general, we want to avoid cyclic graph of action. This option enables updating DataObjects based on its own data. Therewith, the DataObject is input and output at the same time. It needs to be specified as output and as recursiveInputId, but not as input."}),"\n",(0,i.jsxs)(t.p,{children:["Example: assuming an object ",(0,i.jsx)(t.code,{children:"stg-src"}),", which data should be added to an growing table ",(0,i.jsx)(t.code,{children:"int-tgt"}),"."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"  action1 {\n    type = CustomDataFrameAction\n    inputIds = [stg-src]\n    outputIds = [int-tgt]\n    recursiveInputIds = [int-tgt]\n    ...\n"})})]})}function u(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>c,a:()=>o});var i=n(7294);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);