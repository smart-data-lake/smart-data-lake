"use strict";(self.webpackChunksmart_data_lake=self.webpackChunksmart_data_lake||[]).push([[1760],{5170:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>d,toc:()=>u});var a=n(5893),r=n(1151),i=n(4866),s=n(5162);const o={id:"incremental-mode",title:"Incremental Mode"},l=void 0,d={id:"getting-started/part-3/incremental-mode",title:"Incremental Mode",description:"Goal",source:"@site/docs/getting-started/part-3/incremental-mode.md",sourceDirName:"getting-started/part-3",slug:"/getting-started/part-3/incremental-mode",permalink:"/docs/getting-started/part-3/incremental-mode",draft:!1,unlisted:!1,editUrl:"https://github.com/smart-data-lake/smart-data-lake/tree/documentation/docs/getting-started/part-3/incremental-mode.md",tags:[],version:"current",frontMatter:{id:"incremental-mode",title:"Incremental Mode"},sidebar:"tutorialSidebar",previous:{title:"Custom Webservice",permalink:"/docs/getting-started/part-3/custom-webservice"},next:{title:"Common Problems",permalink:"/docs/getting-started/troubleshooting/common-problems"}},c={},u=[{value:"Goal",id:"goal",level:2},{value:"Define Data Objects",id:"define-data-objects",level:2},{value:"Define state variables",id:"define-state-variables",level:2},{value:"Read and write state",id:"read-and-write-state",level:2},{value:"Try it out",id:"try-it-out",level:2},{value:"Define a Query Logic",id:"define-a-query-logic",level:2}];function h(e){const t={a:"a",admonition:"admonition",br:"br",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"goal",children:"Goal"}),"\n",(0,a.jsxs)(t.p,{children:["The goal of this part is to use the DataObject's state, such that it can be used in subsequent requests.\nThis allows for more dynamic querying of the API.\nFor example in the ",(0,a.jsx)(t.code,{children:"ext-departures"})," DataObject we currently query the API with fixed airport, begin and end query parameters.\nConsequently, we will always query the same time period for a given airport.\nIn a more real-world example, we would want a delta load mechanism that loads any new data since the last execution of the action.\nTo demonstrate these incremental queries based on previous state we will start by rewriting our configuration file."]}),"\n",(0,a.jsx)(t.h2,{id:"define-data-objects",children:"Define Data Objects"}),"\n",(0,a.jsxs)(t.p,{children:["We only make the following minor changes in our config file to Action ",(0,a.jsx)(t.code,{children:"download-deduplicate-departures"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'download-deduplicate-departures {\n  type = DeduplicateAction\n  inputId = ext-departures\n  outputId = int-departures\n  executionMode = { type = DataObjectStateIncrementalMode }\n  mergeModeEnable = true\n  updateCapturedColumnOnlyWhenChanged = true\n  transformers = [{\n    type = SQLDfTransformer\n    code = "select ext_departures.*, date_format(from_unixtime(firstseen),\'yyyyMMdd\') dt from ext_departures"\n  },{\n    type = ScalaCodeSparkDfTransformer\n    code = """\n      import org.apache.spark.sql.{DataFrame, SparkSession}\n      def transform(session: SparkSession, options: Map[String,String], df: DataFrame, dataObjectId: String) : DataFrame = {\n        import session.implicits._\n        df.dropDuplicates("icao24", "estdepartureairport", "dt")\n      }\n      // return as function\n      transform _\n    """\n  }]\n  metadata {\n    feed = deduplicate-departures\n  }\n}\n'})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Adding the executionMode ",(0,a.jsx)(t.code,{children:"DataObjectStateIncrementalMode"})," will enable DataObject incremental mode. With every run the input DataObject will only return new data in this mode.\nThe DataObject saves its state in the global state file that is written after each run of the Smart Data Lake Builder. You haven't worked with this state file before, more on that later."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"mergeModeEnable = true"})," tells DeduplicateAction to merge changed data into the output DataObject, instead of overwriting the whole DataObject. This is especially useful if incoming data is read incrementally.\nThe output DataObject must implement CanMergeDataFrame interface (also called trait in Scala) for this. DeltaLakeTableDataObject will then create a complex SQL-Upsert statement to merge new and changed data into existing output data."]}),"\n",(0,a.jsxs)(t.li,{children:["By default DeduplicateAction updates column dl_captured in the output for every record it receives. To reduce the number of updated records, ",(0,a.jsx)(t.code,{children:"updateCapturedColumnOnlyWhenChanged = true"})," can be set.\nIn this case column dl_captured is only updated in the output, when some attribute of the record changed."]}),"\n"]}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsx)(t.p,{children:"Execution mode is also something that is going to be explained in more detail later.\nFor now, just think of the execution mode as a way to select which data needs to be processed.\nIn this case, we tell Smart Data Lake Builder to load data based on the state stored in the DataObject itself."})}),"\n",(0,a.jsx)(t.admonition,{type:"caution",children:(0,a.jsxs)(t.p,{children:["Remember that the time interval in ",(0,a.jsx)(t.code,{children:"ext-departures"})," should not be larger than a week. As mentioned, we will implement a simple incremental query logic that always queries from the last execution time until the current execution.\nIf the time difference between the last execution and the current execution time is larger than a week, we will query the next four days since the last execution time. Otherwise we query the data from the last execution until now."]})}),"\n",(0,a.jsx)(t.h2,{id:"define-state-variables",children:"Define state variables"}),"\n",(0,a.jsx)(t.p,{children:"To make use of the newly configured execution mode, we need state variables. Add the following two variables to our CustomWebserviceDataObject."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"  private var previousState : Seq[State] = Seq()\n  private var nextState : Seq[State] = Seq()\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The corresponding ",(0,a.jsx)(t.code,{children:"State"})," case class is defined as"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"  case class State(airport: String, nextBegin: Long)\n"})}),"\n",(0,a.jsxs)(t.p,{children:["and should be added in the same file outside the DataObject. For example, add it just below the already existing case classes.\nThe state always stores the ",(0,a.jsx)(t.code,{children:"airport"})," and a ",(0,a.jsx)(t.code,{children:"nextBegin"})," as unix timestamp to indicate to the next run, what data needs to be loaded."]}),"\n",(0,a.jsxs)(t.p,{children:["Concerning the state variables, ",(0,a.jsx)(t.code,{children:"previousState"})," will basically be used for all the logic of the DataObject and ",(0,a.jsx)(t.code,{children:"nextState"})," will be used to store the state for the next run."]}),"\n",(0,a.jsx)(t.h2,{id:"read-and-write-state",children:"Read and write state"}),"\n",(0,a.jsxs)(t.p,{children:["To actually work with the state, we need to implement the ",(0,a.jsx)(t.code,{children:"CanCreateIncrementalOutput"})," trait.\nThis can be done by adding ",(0,a.jsx)(t.code,{children:"with CanCreateIncrementalOutput"})," to the ",(0,a.jsx)(t.code,{children:"CustomWebserviceDataObject"}),".\nConsequently, we need to implement the functions ",(0,a.jsx)(t.code,{children:"setState"})," and ",(0,a.jsx)(t.code,{children:"getState"})," defined in the trait."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"override def setState(state: Option[String])(implicit context: ActionPipelineContext): Unit = {\n  implicit val formats: Formats = DefaultFormats\n  previousState = state.map(s => JsonMethods.parse(s).extract[Seq[State]]).getOrElse(Seq())\n}\n\noverride def getState: Option[String] = {\n  implicit val formats: Formats = DefaultFormats\n  Some(Serialization.write(nextState))\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"We can see that by implementing these two functions, we start using the variables defined in the section above."}),"\n",(0,a.jsx)(t.h2,{id:"try-it-out",children:"Try it out"}),"\n",(0,a.jsxs)(t.p,{children:["We only spoke about this state, but it was never explained where it is stored.\nTo work with a state, we need to introduce two new command line parameters: ",(0,a.jsx)(t.code,{children:"--state-path"})," and ",(0,a.jsx)(t.code,{children:"--name"})," or ",(0,a.jsx)(t.code,{children:"-n"})," in short.\nThis allows us to define the folder and name of the state file.\nTo have access to the state file, we specify the path to be in an already mounted folder."]}),"\n",(0,a.jsxs)(i.Z,{groupId:"docker-podman-switch",defaultValue:"docker",values:[{label:"Docker",value:"docker"},{label:"Podman",value:"podman"}],children:[(0,a.jsx)(s.Z,{value:"docker",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:'docker run -v ${PWD}:/mnt/project -v ${PWD}/.mvnrepo:/mnt/.mvnrepo maven:3.6.0-jdk-11-slim -- mvn -f /mnt/project/pom.xml "-Dmaven.repo.local=/mnt/.mvnrepo" package\ndocker run --rm -v ${PWD}/data:/mnt/data -v ${PWD}/target:/mnt/lib -v ${PWD}/config:/mnt/config --network getting-started_default sdl-spark:latest --config /mnt/config --feed-sel ids:download-deduplicate-departures --state-path /mnt/data/state -n getting-started\n'})})}),(0,a.jsx)(s.Z,{value:"podman",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:'podman run -v ${PWD}:/mnt/project -v ${PWD}/.mvnrepo:/mnt/.mvnrepo maven:3.6.0-jdk-11-slim -- mvn -f /mnt/project/pom.xml "-Dmaven.repo.local=/mnt/.mvnrepo" package\npodman run --rm -v ${PWD}/data:/mnt/data -v ${PWD}/target:/mnt/lib -v ${PWD}/config:/mnt/config --hostname=localhost --pod getting-started sdl-spark:latest --config /mnt/config --feed-sel ids:download-deduplicate-departures --state-path /mnt/data/state -n getting-started\n'})})})]}),"\n",(0,a.jsxs)(t.p,{children:["Use this slightly modified command to run ",(0,a.jsx)(t.code,{children:"download-deduplicate-departures"})," Action.\nNothing should have changed so far, since we only read and write an empty state.",(0,a.jsx)(t.br,{}),"\n","You can verify this by opening the file ",(0,a.jsx)(t.code,{children:"getting-started.<runId>.<attemptId>.json"})," and having a look at the field ",(0,a.jsx)(t.code,{children:"dataObjectsState"}),". The stored state is currently empty.\nIn the next section, we will assign a value to ",(0,a.jsx)(t.code,{children:"nextState"}),", such that the ",(0,a.jsx)(t.code,{children:"DataObject's"})," state is written."]}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsxs)(t.p,{children:["The same state file is used by Smart Data Lake Builder to enable automatic recoveries of failed jobs.\nThis will also be explained in detail separately, but we're mentioning the fact here, so you can understand the two variables ",(0,a.jsx)(t.code,{children:"<runId>"})," and ",(0,a.jsx)(t.code,{children:"<attemptId>"})," appearing in the file name.\nFor each execution, the ",(0,a.jsx)(t.code,{children:"<runId>"})," is incremented by one.\nThe ",(0,a.jsx)(t.code,{children:"<attemptId>"})," is usually 1, but gets increased by one if Smart Data Lake Builder has to recover a failed execution."]})}),"\n",(0,a.jsx)(t.h2,{id:"define-a-query-logic",children:"Define a Query Logic"}),"\n",(0,a.jsx)(t.p,{children:"Now we want to achieve the following query logic:"}),"\n",(0,a.jsxs)(t.p,{children:["The starting point are the query parameters provided in the configuration file and no previous state.\nDuring the first execution, we query the departures for the two airports in the given time window.\nIf no begin and end time are provided, we take the interval of [2 weeks and 2 days ago] -> [2 weeks ago] as a starting point.\nAfterwards, the ",(0,a.jsx)(t.code,{children:"end"}),"-parameter of the current query will be stored as ",(0,a.jsx)(t.code,{children:"begin"}),"-parameter for the next query.\nNow the true incremental phase starts as we can now get the state of the last successful run.\nWe query the flight-data API to get data from the last successful run up until now.\nFor this to work, we need to make two changes. First add the variable"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"private val now = Instant.now.getEpochSecond\n"})}),"\n",(0,a.jsxs)(t.p,{children:["just below the ",(0,a.jsx)(t.code,{children:"nextState"})," variable. Then modify the ",(0,a.jsx)(t.code,{children:"currentQueryParameters"})," variable according to"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"// if we have query parameters in the state we will use them from now on\nval currentQueryParameters = if (previousState.isEmpty) checkQueryParameters(queryParameters) else checkQueryParameters(previousState.map{\n  x => DepartureQueryParameters(x.airport, x.nextBegin, now)\n})\n"})}),"\n",(0,a.jsx)(t.p,{children:"The implemented logic"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:"nextState = currentQueryParameters.map(params => State(params.airport, params.end))\n"})}),"\n",(0,a.jsxs)(t.p,{children:["for the next state can be placed below the comment ",(0,a.jsx)(t.code,{children:"// put simple nextState logic below"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Compile and execute the code of this project again and execute it multiple times.\nThe scenario will be that the first run fetches the data defined in the configuration file, then the proceeding run retrieves the data from the endpoint of the last run until now.\nIf this time difference is larger than a week, the program only queries the next four days since the last execution.\nIf there is no data available in a time window, because only a few seconds have passed since the last execution, the execution will fail with Error ",(0,a.jsx)(t.strong,{children:"404"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["At the end your config file should look something like ",(0,a.jsx)(t.a,{target:"_blank",href:n(2196).Z+"",children:"this"})," and the CustomWebserviceDataObject code like ",(0,a.jsx)(t.a,{target:"_blank",href:n(355).Z+"",children:"this"}),"."]}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsxs)(t.p,{children:["Unfortunately, the webservice on opensky-network.org responds with a ",(0,a.jsx)(t.strong,{children:"404"})," error code when no data is available, rather than a ",(0,a.jsx)(t.strong,{children:"200"})," and an empty response.\nTherefore, SDLB gets a 404 and will fail the execution. The exception could be catched inside CustomWebserviceDataObject, but what if we have a real 404 error?!"]})}),"\n",(0,a.jsx)(t.p,{children:"Congratulation, you just completed implementing a nice incremental loading mechanism!"}),"\n",(0,a.jsx)(t.p,{children:"That's it from getting-started for now. We hope you enjoyed your first steps with SDLB.\nFor further information, check the rest of the documentation and the blog on this page!"})]})}function m(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},5162:(e,t,n)=>{n.d(t,{Z:()=>s});n(7294);var a=n(6010);const r={tabItem:"tabItem_Ymn6"};var i=n(5893);function s(e){let{children:t,hidden:n,className:s}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.Z)(r.tabItem,s),hidden:n,children:t})}},4866:(e,t,n)=>{n.d(t,{Z:()=>y});var a=n(7294),r=n(6010),i=n(2466),s=n(6550),o=n(469),l=n(1980),d=n(7392),c=n(12);function u(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??function(e){return u(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}(n);return function(e){const t=(0,d.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function p(e){let{queryString:t=!1,groupId:n}=e;const r=(0,s.k6)(),i=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(i),(0,a.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(r.location.search);t.set(i,e),r.replace({...r.location,search:t.toString()})}),[i,r])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,i=h(e),[s,l]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[d,u]=p({queryString:n,groupId:r}),[f,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,i]=(0,c.Nk)(n);return[r,(0,a.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:r}),x=(()=>{const e=d??f;return m({value:e,tabValues:i})?e:null})();(0,o.Z)((()=>{x&&l(x)}),[x]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),g(e)}),[u,g,i]),tabValues:i}}var g=n(2389);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=n(5893);function w(e){let{className:t,block:n,selectedValue:a,selectValue:s,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:d}=(0,i.o5)(),c=e=>{const t=e.currentTarget,n=l.indexOf(t),r=o[n].value;r!==a&&(d(t),s(r))},u=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":n},t),children:o.map((e=>{let{value:t,label:n,attributes:i}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:a===t?0:-1,"aria-selected":a===t,ref:e=>l.push(e),onKeyDown:u,onClick:c,...i,className:(0,r.Z)("tabs__item",x.tabItem,i?.className,{"tabs__item--active":a===t}),children:n??t},t)}))})}function j(e){let{lazy:t,children:n,selectedValue:r}=e;const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:i.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==r})))})}function v(e){const t=f(e);return(0,b.jsxs)("div",{className:(0,r.Z)("tabs-container",x.tabList),children:[(0,b.jsx)(w,{...e,...t}),(0,b.jsx)(j,{...e,...t})]})}function y(e){const t=(0,g.Z)();return(0,b.jsx)(v,{...e,children:u(e.children)},String(t))}},355:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/CustomWebserviceDataObject-2-e9ab5bd18480b88edc29415e31e70fa2.scala"},2196:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/application-part3-download-incremental-mode-7e479e1edd0413f13ee33306c5df0638.conf"},1151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>s});var a=n(7294);const r={},i=a.createContext(r);function s(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);